<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oracle of Shadows</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&family=UnifrakturMaguntia&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'IM Fell English SC', serif;
            background-color: #121212;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%232a2a2a' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            text-shadow: 0 0 5px rgba(155, 89, 182, 0.3);
        }
        .font-unifraktur {
            font-family: 'UnifrakturMaguntia', cursive;
        }
        .scrying-orb {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle at 35% 35%, #9b59b6, #3a1c50 60%, #1a0b24 100%);
            border-radius: 50%;
            border: 4px solid #3c1e54;
            box-shadow: 
                inset 0 0 60px rgba(0,0,0,0.8),
                0 0 15px #4a0e6b,
                0 0 30px #8e44ad,
                0 0 45px #9b59b6 inset;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .scrying-orb:hover {
            box-shadow: 
                inset 0 0 60px rgba(0,0,0,0.9),
                0 0 20px #4a0e6b,
                0 0 40px #8e44ad,
                0 0 60px #9b59b6,
                0 0 50px #9b59b6 inset;
            transform: scale(1.03);
        }
        .orb-window {
            width: 160px;
            height: 160px;
            background: radial-gradient(ellipse at center, #111 0%, #000 100%);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            overflow: hidden;
            border: 2px solid #2a0a3d;
            box-shadow: inset 0 0 35px #000;
            position: relative;
        }
        .orb-window::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: radial-gradient(rgba(155, 89, 182, 0.2) 20%, transparent 60%);
            animation: swirl 10s linear infinite;
        }
        #answer-text {
            color: #e6e6fa; /* Lavender */
            font-size: 16px;
            font-weight: normal;
            opacity: 1;
            transition: opacity 1s ease-in-out, transform 1s ease-in-out;
            text-shadow: 0 0 8px #9b59b6, 0 0 12px #d8b2f2;
            animation: float 4s ease-in-out infinite;
            z-index: 10;
            line-height: 1.3;
        }
        
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        
        @keyframes swirl {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        
        @keyframes pulse {
            50% { opacity: 0.6; }
        }

        .shaking {
            animation: shake 0.82s cubic-bezier(.36,.07,.19,.97) both;
        }
        .loading-text {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="bg-black text-gray-300 flex flex-col items-center justify-center min-h-screen p-4">
    <!-- Main container for the oracle -->
    <div id="oracle-container" class="w-full max-w-md mx-auto text-center">
        
        <h1 class="font-unifraktur text-6xl md:text-7xl text-purple-300 mb-2" style="text-shadow: 0 0 10px #9b59b6;">Oracle of Shadows</h1>
        <p class="text-gray-400 mb-8 tracking-wider">The aether awaits your question...</p>

        <!-- The Scrying Orb -->
        <div id="scrying-orb" class="scrying-orb mx-auto mb-8">
            <div class="orb-window">
                <span id="answer-text">?</span>
            </div>
        </div>
        
        <!-- Input and Buttons -->
        <div class="w-full space-y-3">
            <input type="text" id="question-input" placeholder="Inscribe your query..." class="w-full bg-gray-900/50 border border-purple-800 text-gray-300 placeholder-gray-500 rounded-md px-4 py-3 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-shadow">
            <button id="ask-button" class="w-full bg-purple-900/80 hover:bg-purple-800/90 text-gray-200 font-bold py-3 px-6 rounded-md shadow-lg shadow-purple-900/50 hover:shadow-purple-800/60 transition-all duration-300 transform hover:scale-105 tracking-widest disabled:opacity-50 disabled:cursor-not-allowed">
                Gaze into the Orb
            </button>
            <button id="prophecy-button" class="w-full bg-transparent border-2 border-purple-700 hover:bg-purple-900/40 text-purple-300 font-bold py-3 px-6 rounded-md shadow-lg shadow-purple-900/30 hover:shadow-purple-800/40 transition-all duration-300 transform hover:scale-105 tracking-widest disabled:opacity-50 disabled:cursor-not-allowed">
                âœ¨ Unveil a Deeper Prophecy
            </button>
            <p id="error-message" class="text-purple-400 mt-4 h-5"></p>
        </div>

    </div>

    <script>
        const scryingOrb = document.getElementById('scrying-orb');
        const answerText = document.getElementById('answer-text');
        const askButton = document.getElementById('ask-button');
        const prophecyButton = document.getElementById('prophecy-button');
        const questionInput = document.getElementById('question-input');
        const errorMessage = document.getElementById('error-message');

        const gothAnswers = [
            "The stars bleed a grim yes.", "As I see it, in the darkest way, yes.", "The abyss gazes back with a 'no'.",
            "A future as bleak as a forgotten tomb.", "Signs point to a sorrowful yes.", "Don't count on it, child of the night.",
            "The threads of fate are tangled. Ask again.", "My sources in the shadow realm say so.", "It is decidedly so, with a hint of despair.",
            "Cannot predict now; the void is silent.", "Outlook... not so good.", "The spirits are restless. Try again.",
            "Without a doubt, like death itself.", "You may rely on it, for what little that's worth.", "Very doubtful. The omens are poor.",
            "The answer is shrouded in fog.", "It is certain, like the coming dusk.", "My reply is a resounding 'no'.",
            "Yes, but at what cost?", "Concentrate and ask again when the moon weeps."
        ];

        function getAnswer() {
            if (questionInput.value.trim() === '') {
                errorMessage.textContent = 'The void cannot answer an unasked question.';
                return;
            }
            errorMessage.textContent = '';
            
            answerText.style.opacity = '0';
            scryingOrb.classList.add('shaking');
            
            setTimeout(() => {
                scryingOrb.classList.remove('shaking');
                const randomIndex = Math.floor(Math.random() * gothAnswers.length);
                answerText.textContent = gothAnswers[randomIndex];
                answerText.style.opacity = '1';
            }, 1000);
        }

        // --- Gemini API Feature ---

        async function getProphecy() {
            const question = questionInput.value.trim();
            if (question === '') {
                errorMessage.textContent = 'A prophecy requires a query of substance.';
                return;
            }
            errorMessage.textContent = '';
            
            // Disable buttons and show loading state
            setLoading(true);

            const apiKey = ""; // API key is handled by the environment, leave blank.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const systemPrompt = "You are the Oracle of Shadows. Your voice is ancient, steeped in mystery and gothic prose. You never give a direct or simple answer. Instead, you weave prophecies from the threads of fate.";
            const userQuery = `A mortal seeks guidance. Their question is: "${question}". Respond with a short, cryptic, three-line poem that hints at the future, leaving them to ponder its true meaning. Your tone must be dark and poetic.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };
            
            try {
                // Using exponential backoff for retries
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`The aether is disturbed. Status: ${response.status}`);
                }

                const result = await response.json();
                const prophecyText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (prophecyText) {
                    displayProphecy(prophecyText.trim());
                } else {
                    throw new Error("The oracle's whispers are indecipherable.");
                }
            } catch (error) {
                console.error("Error fetching prophecy:", error);
                displayProphecy("The connection to the shadow realm has been severed. Try again when the stars align.");
            } finally {
                setLoading(false);
            }
        }

        function displayProphecy(text) {
             answerText.textContent = text;
             answerText.style.opacity = '1';
        }

        function setLoading(isLoading) {
            askButton.disabled = isLoading;
            prophecyButton.disabled = isLoading;
            if (isLoading) {
                answerText.style.opacity = '0';
                setTimeout(() => {
                    answerText.textContent = 'The aether stirs...';
                    answerText.classList.add('loading-text');
                    answerText.style.opacity = '1';
                }, 500);
            } else {
                 answerText.classList.remove('loading-text');
            }
        }
        
        // Utility function for fetch with exponential backoff
        async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status !== 429) { // Not a rate limit error
                        return response;
                    }
                    // It is a rate limit error, wait and retry
                    console.warn(`Rate limited. Retrying in ${delay / 1000}s...`);
                } catch (error) {
                    // Network or other errors
                    if (i === retries - 1) throw error; // Rethrow last error
                }
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2; // Exponential backoff
            }
            throw new Error("Max retries reached.");
        }


        // Event Listeners
        askButton.addEventListener('click', getAnswer);
        prophecyButton.addEventListener('click', getProphecy);
        
        questionInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                // Default to the classic answer on Enter
                getAnswer();
            }
        });
        
        scryingOrb.addEventListener('click', getAnswer);

    </script>
</body>
</html>

